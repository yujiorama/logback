<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"></meta>
    <title>HTTPリクエストとHTTPレスポンスをキャプチャする</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css"></link>
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen"></link>
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print"></link>
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen"></link>

  </head>
  <body dir="ltr" onload="prettyPrint()">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <div id="left">
      <noscript>このメニューを表示するにはJavaScriptをONにしてください</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="content">
      
      <h2>HTTPリクエストとHTTPレスポンスをキャプチャする</h2>

      <p>logback-accessというモジュールは、JettyやTomcatなどのサーブレットコンテナと統合して、リッチで強力なHTTPアクセスをロギングするものです。
      </p>

      <p>Webアプリケーションの問題を診断するとき、HTTPリクエストとHTTPレスポンスがキャプチャできると非常に役に立ちます。<a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a>のようなWebサービスの場合は特にそうで、そのままのSOAPメッセージにアクセスできれば、名前空間のスペルミスやフィールドの欠落のような原因をすぐに突き止めることが出来ます。
      </p>

      <p>Webサービスの実行環境によっては、SOAPトラフィックのロギングは簡単に設定できるようになっています。たとえば、JBoss のWebサービススタックなら、<code>org.jboss.ws.core.MessageTrace</code>ロガーのログレベルを<code>TRACE</code>にすれば、SOAPメッセージのトレースが有効になります。これは<a href="http://community.jboss.org/wiki/JBossWS-Log4j">JBossのWikiに記載されています</a>。
      </p>

      <p>Metroなど他のWebサービススタックを使っているなら、SOAPメッセージのトレースを有効化するのはとても手間がかかることかもしれません。そういう場合、もしくはアプリケーションがTomcatにデプロイされそうな場合は、<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Request_Dumper_Filter">RequestDumperFilter</a>を有効化したくなるかもしれません。しかし、残念ながら<code>RequestDumperFilter</code>はインストールが難しいだけでなく、リクエストとレスポンスのペイロードをダンプしないのです。
      </p>

      <p><a href="../access.html#teeFilter">logback-accessのTeeFilter</a>を使えば、リクエストごとの完全な入出力をキャプチャーすることができます。
  
      </p>

      <h3><a name="capturing" href="#capturing">キャプチャー</a></h3>

      <p><code>TeeFilter</code>を使うには、他のサーブレットフィルターと同じく、アプリケーションの<em>web.xml</em>で宣言しなければなりません。次のような宣言をあなたのアプリケーションの<em>web.xml</em>に追加してください。
      </p>

    <pre class="prettyprint source">&lt;filter&gt;
  &lt;filter-name&gt;TeeFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;ch.qos.logback.access.servlet.TeeFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;TeeFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</pre>

      <p><code>TeeFilter</code>を使うには、あなたのWebサーバーにlogback-accessモジュールをインストールしなければなりません。logback-accesのインストールの仕方は<a href="../access.html">別のドキュメント</a>で説明してあります。JettyやTomcatなどのサーブレットコンテナにlogback-accessをインストールしたら、<em>logback-access.xml</em>という設定ファイルでlogback-accessの振る舞いを設定できるようになります。
      </p>
      
      <p>完全なリクエストとレスポンスをコンソールに出力する<em>logback-access.xml</em>は次のようなものです。
      </p>

  <pre class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;      
      &lt;pattern&gt;<b>%fullRequest</b>%n%n<b>%fullResponse</b>&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
	
  &lt;appender-ref ref="STDOUT" /&gt;
&lt;/configuration&gt;</pre>
      
     <p>logback-accessがサポートしている変換指示子については、logback-accessの<code>PatternLayout</code>の<a href="manual/layouts.html#AccessPatternLayout">マニュアル</a>を参照してください。
     </p>

     <p><a href="../demo.html">logback-demo</a>アプリケーションで前の設定ファイルを使った場合の出力は次のようになります。</p>

     <p class="source"><b>GET /logback-demo/index.jsp HTTP/1.1</b>
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8) Gecko/20070312 Firefox/1.5.0
Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://localhost:8080/logback-demo/login.jsp
Cookie: JSESSIONID=15c7tqi9ehlwk;  OID324nkzcmr=null; OID32862zgoa=null; 



<b>HTTP/1.1 200 OK</b>
Content-Type: text/html; charset=iso-8859-1
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Set-Cookie: JSESSIONID=bgebt99ce9om;path=/logback-demo


&lt;html&gt;
&lt;head&gt;
        &lt;LINK REL=StyleSheet HREF="css/pk.css" /&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Logback demo center&lt;/h2&gt;

[snip, so that text is reasonably sized]</p>

<p> </p>

      <h3><a name="disabling" href="#disabling">本番環境で<code>TeeFilter</code>を無効化する</a></h3>

      <p><code>TeeFilter</code>は侵入的にデータを扱うものなので、性能が劣化する可能性があります。また、私たちは現在既知の不具合を全て修正したものの、<code>TeeFilter</code>を有効化する前は正常だったアプリケーションが動かなくなった、という事例もあります。したがって、原因追跡には極めて有効ですが、本番環境で<code></code>TreeFilter{/0]を常時有効化しておくことはお勧めできません。テスト環境と本番環境で別の設定ファイルを扱うようになるのを避けるため、<code>TeeFilter</code>はincludeとexcludeパラメータが用意されています。現在のホストがincludeに存在し、excludeに存在しなければ、<code>TeeFilter</code>は有効になります。特別ルールとして、空の<em>include</em>はすべてのホスト名が含まれているものとして解釈されます。
      </p>
      
      <p>orionとgeminiを除くすべてのホストでHTTPトラフィックをキャプチャーしたい場合、次のように指定します。</p>

        <pre class="prettyprint source">&lt;filter&gt;
  &lt;filter-name&gt;TeeFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;ch.qos.logback.access.servlet.TeeFilter&lt;/filter-class&gt;
  &lt;init-param&gt;
    <b>&lt;!-- exclude captures on production systems --&gt;</b>
    &lt;param-name&gt;<b>excludes</b>&lt;/param-name&gt;
    &lt;param-value&gt;orion, gemini&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/filter&gt;  </pre>
  
      <p>対象マシンに明示的に名前を付けるほうが簡単なら、その名前をincludeのリストに並べて、excludeを省略することもできます。
      </p>

      <h3><a name="filtering" href="#filtering">キャプチャーしたリクエストのフィルタリング</a></h3>

      <p>アプリケーションがクラスターサーバーにデプロイされていることにします。クラスターは負荷分散装置の背後に置かれており、負荷分散装置は一秒あたり一度か二度の頻度でクラスターのメンバーの死活監視を行います。メンバーが死んでしまったら、負荷分散装置はすぐに（せいぜい一秒ほど後になってから）トラフィックを他のメンバーに割り振るようになります。
      </p>

      <p>この負荷分散戦略が必要なのは、アプリケーションの可用性を保証するためです。しかし、負荷分散装置による死活監視によってアクセスログが汚れてしまうのはそれはそれで深刻な問題です。
      </p>

      <p>死活監視のためのアクセスを除外して、ログ出力が汚染されないようにしなければなりません。言い換えると、負荷分散装置からの死活監視と、他のクライアントからのリクエストを区別しなければなりません。死活監視の内容が手がかりになることもあります。</p>

      <p>死活監視のアクセスをlogback-accessで出力すると次のようになります。</p>

      <pre class="source"><b>HEAD</b> /myapp/<b>probe</b> HTTP/1.1
connection: Close
host: 192.168.1.1

HTTP/1.1 200 OK
Expires: Thu, 01 Jan 1970 01:00:00 CET
X-Powered-By: Servlet 2.4;
Cache-Control: no-cache
Pragma: No-cache </pre>

      <p>つまり、負荷分散装置からの死活監視は、普通使われているGETやPOSTではなく、<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4">HTTP HEADメソッド</a>であることが分かります。また、リクエストURLに"probe"という文字列が含まれている、ということも分かります。</p>

      <p>この<em>logback-access.xml</em>では、HEADメソッドの<code>AccessEvent</code>はすべて拒否しています。評価器として使っている<code>JaninoEventEvaluator</code>にはJaninoライブラリが必要です。</p>

      <pre class="prettyprint source">&lt;configuration&gt;
  &lt;!-- always a good idea to install OnConsoleStatusListener --&gt;
  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter"&gt;
      &lt;!-- in the absence of a class attribute the &lt;evaluator&gt; element 
           defaults to ch.qos.logback.access.boolex.JaninoEventEvaluator --&gt;
      &lt;evaluator&gt;
        &lt;expression&gt;<b>event.getMethod().equals("HEAD")</b>&lt;/expression&gt;
      &lt;/evaluator&gt;
      &lt;onMismatch&gt;NEUTRAL&lt;/onMismatch&gt;
      &lt;onMatch&gt;DENY&lt;/onMatch&gt;
    &lt;/filter&gt;

    &lt;encoder&gt;
      &lt;pattern&gt;%fullRequest%n%n%fullResponse&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;appender-ref ref="STDOUT" /&gt;
&lt;/configuration&gt; </pre>
      
      <script src="../templates/footer.js" type="text/javascript"></script>	
    </div>
  </body>
</html>